# 孤儿进程和僵尸进程

在操作系统中，**孤儿进程**和**僵尸进程**是进程生命周期中两种特殊的状态，它们的产生与父子进程的关系密切相关。

---

## **1. 孤儿进程（Orphan Process）**

### **定义**  

当**父进程终止**（或被杀死），但其**子进程仍在运行**时，该子进程就会成为孤儿进程。  
操作系统会将孤儿进程的父进程重置为 **`init` 进程**（PID=1），由 `init` 负责后续管理。

### **产生场景**  

```c
#include <unistd.h>
#include <stdio.h>

int main() {
    pid_t pid = fork();
    if (pid == 0) {  // 子进程
        sleep(5);    // 子进程休眠5秒
        printf("子进程运行结束（父进程已终止）\n");
    } else {         // 父进程
        printf("父进程立即终止\n");
    }
    return 0;
}
```

- 父进程创建子进程后立即终止。
- 子进程仍在运行，成为孤儿进程，由 `init` 接管。

### **特点**  

- 无害，`init` 进程会负责回收资源。
- 不影响系统性能。

---

## **2. 僵尸进程（Zombie Process）**

### **定义**  

当**子进程终止**，但其**父进程未调用 `wait()` 或 `waitpid()`** 回收其退出状态时，子进程的进程描述符（PCB）会残留在系统进程表中，成为僵尸进程。

### **产生场景**  

```c
#include <unistd.h>
#include <stdio.h>

int main() {
    pid_t pid = fork();
    if (pid == 0) {  // 子进程
        printf("子进程运行结束\n");
    } else {         // 父进程
        sleep(10);   // 父进程休眠，未调用 wait()
        printf("父进程运行结束\n");
    }
    return 0;
}
```

- 子进程终止后，父进程未及时调用 `wait()`。
- 子进程进入僵尸状态（`Z` 状态）。

### **关键特征**  

- 僵尸进程已终止，不再占用内存，但占用进程表条目。
- 若大量产生，会导致进程表满，无法创建新进程。

### **常见原因**  

1. 父进程未正确处理子进程的退出（未调用 `wait()` 系列函数）。  
2. 父进程被设计为忽略 `SIGCHLD` 信号（默认情况下子进程终止会发送此信号）。  
3. 父进程本身存在缺陷（如死循环），无法执行到 `wait()` 代码。

---

## **3. 如何避免僵尸进程？**

### **(1) 父进程主动回收子进程**

```c
#include <sys/wait.h>

pid_t pid = fork();
if (pid == 0) {
    // 子进程代码
} else {
    wait(NULL);  // 阻塞等待子进程结束
}
```

### **(2) 异步处理（信号捕获）**

```c
#include <signal.h>
#include <sys/wait.h>

void sigchld_handler(int sig) {
    while (waitpid(-1, NULL, WNOHANG) > 0);  // 非阻塞回收所有终止的子进程
}

int main() {
    signal(SIGCHLD, sigchld_handler);  // 注册SIGCHLD信号处理函数
    // ...创建子进程...
}
```

### **(3) 双 `fork` 技巧**  

通过两次 `fork`，让孙子进程成为实际工作进程，父进程直接退出，使孙子进程被 `init` 接管：

```c
pid_t pid = fork();
if (pid == 0) {
    if (fork() == 0) {  // 孙子进程
        // 实际工作代码
    } else {
        exit(0);  // 子进程立即退出
    }
} else {
    wait(NULL);  // 父进程回收子进程
}
```

---

## **总结对比**

|                  | **孤儿进程**                    | **僵尸进程**                    |
|------------------|-------------------------------|-------------------------------|
| **进程状态**      | 仍在运行                       | 已终止                        |
| **父进程状态**    | 已终止                         | 仍在运行（但未调用 `wait()`） |
| **危害性**        | 无害（由 `init` 接管）          | 可能耗尽进程表资源            |
| **解决方案**      | 无需处理                       | 父进程必须调用 `wait()`       |

理解这两种进程状态对开发可靠的并发程序至关重要，尤其是在涉及多进程管理的场景中。
