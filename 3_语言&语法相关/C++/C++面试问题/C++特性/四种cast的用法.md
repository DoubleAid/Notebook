## 四种 cast 的用法
四种cast分别是：dynamic_cast, static_cast, const_cast, reinterpret_cast
## C 风格强制类型转换
C语言风格的强制类型转换比较强大且万能，需要使用类型转换的地方都可以使用C语言风格的强制类型转换进行转换。
正是因为这种万能性，C语言风格的类型转换在使用上没有提供任何约束。没有任何约束代表着无法提供任何检查，包括静态和动态检查，
所以使用此类型转换的时候，需要编程者来负责转换的安全性

C语言风格的类型转换有两种形式，这两种形式都可，就是写法不一样
```c++
T(expression)
(T)expression
```
为了弥补C语言风格强制类型转换无任何约束，无法提供语法层面的类型转换相关的安全检查，C++提供了四种cast来应对不同过的情况

## C++风格强制类型转换
### dynamic_cast动态类型转换
动态类型转换，主要用于面向对象中多态应用场景，用于基类指针和派生类指针或者基类引用和派生类引用的安全转换，提供动态的安全检查。

首先，我们明确基类和派生类之间的两个转换术语
+ 向上转换(upcast)：派生类向基类转换
+ 向下站还(downcast)：基类向派生类转换
这里面的向上和向下是对应于继承树的上下，继承树中，基类在上派生类在下

下面就上面两种类型转换，说明一下dynamic_cast在其中的情况
+ 对于向上类型转换的时候，总是成功并且安全的
+ 对于向下类型转换不都是成功的。对于指针，如果转换不成功，返回空指针。对于引用，如果转换不成功，则会跑出异常(std::bad_cast)
另外，有一个非常重要的点需要注意，这里面派生类基类需要是多态的(polymorphic)，也就是说基类必须有虚函数，否则在进行向下转换时，在编译期间会报错
```c++
B& b = dynamic_cast<B&>(a);
```
上图中的a对象就没有任何虚函数

### static_cast静态类型转换
静态类型转换，在编译期间提供类型转换检查，主要用于非多态的场景（当然也可以用于多态的场景，但是不提供）。
相比较于C语言风格引入了一些静态的约束，比如检查const属性和voliate属性
```c++
 const int g = 20;
 int *h = static_cast<int*>(&g); 
```
上边示例的转换会导致编译错误，因为非const 指针h想要指向一个常量。

+ 对于多态场景，通常使用dynamic_cast。但是也可以static_cast也可以使用
+ 对于向上转换是安全的
+ 对于向下转换总是成功的，并且不提供检查。效果和C风格的强制类型转换是一样的
在处理非多态类型转换的时候，应该优先使用static_cast

### const_cast
用来在不同cv属性的类型的数据之间转换，这里面的cv指的是constness和volatility

### reinterpret_cast
通过对底层字节数据进行重新解释来进行类型转换。不同于static_cast，reinterpret_cast不会变成任何机器指令（整型数据与指针之间的转换除外或者在一些复杂的指令架构中）。
它是一个单纯的编译器命令，用来告诉编译器这个表达式应该当成什么类型来看待

值得注意的是，其不能用来处理cv属性，如果转换前后的类型中的cv属性不一致，则无法进行转换，编译会报错，如下图所示
```c++
const int a = 50;
B& b = reinterpret_cast<B&>(a);
```
## 总结
在实际应用实践中，判断如何使用上边四种转换的方式通过如下的思路选择
+ 如果是多态应用场景中，在基类和派生类进行类型转换（指针或者引用），则优先使用dynamic_cast
+ 如果是不涉及到cv属性的变化的时候，并且非多态应用场景下，优先使用static_cast
+ 如果需要改变cv属性，使用const_cast
+ 最后选择使用reinterpret_cast进行转换，或者几种转换组合使用
