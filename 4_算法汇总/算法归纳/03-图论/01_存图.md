所谓图（graph）， 是图论中基本的数学对象， 包括一些顶点和连接顶点的边， 这里的边只是表示顶点的连接情况， 用直线或曲线表示。图可以分为 有向图 和 无向图， 有向图中的边是有方向的， 无向图的边是双向联通的

对于设计到图的问题， 首先要把图存储起来， 这个过程称为 存图

## 邻接矩阵
谈到存图， 最朴素的想法是用一个二维数组 mat[] 存储两个边的连接情况。 假如从 顶点u 到 顶点 v 有一条边， 则 mat[u][v] = 1。这种建图方法称为邻接矩阵。 假如上面的那张图有向图的临界矩阵是

邻接矩阵的优点显而易见：简单好写，查询速度快。但缺点也很明显：空间复杂度太高了。 个点对应大小

的数组，如果点的数量达到10000，这种方法就完全不可行了。

事实上，我们可以看到，上面那两个矩阵中有大量的元素是0，有大量空间被浪费了。这虽然使得我们可以迅速判断两个点之间是否没有边，但我们为此付出的代价太大了，我们其实更关注那些确实存在的边。我们希望，可以跳过这些0，直达有边的地方，就像下面这样：

```
   1 2 3 4 5
1 [- - - - 1]
2 [- - - - 1]
3 [- - - 1 -]
4 [- - - - -]
5 [- - 1 1 -]
```
## 邻接表
上面那张表可以认为是邻接表的雏形。我们把邻接矩阵的行从数组替换为链表。当然上面那张表并不准确，因为用链表替换数组后，下标也就不复存在了。所以我们需要用一个结构体来同时储存边的终点（相当于邻接矩阵的第二个下标）和权值

## 链式前向星
另一种思路是用数组模拟链表，这样的存图方法有一个听上去很高端的名字：链式前向星。因为STL常数大，我个人更喜欢这种方法。不过它写起来稍微复杂一点。
```C++
struct Edge
{
    int to, w, next;
}edges[MAXM];
int head[MAXN], cnt; // cnt为当前边的编号
inline void add(int from, int to, int w)
{
    edges[++cnt].w = w;    //新增一条编号为cnt+1的边，边权为w
    edges[cnt].to = to;    //该边的终点为to
    edges[cnt].next = head[from];  //把下一条边，设置为当前起点的第一条边
    head[from] = cnt;  //该边成为当前起点新的第一条边
}
```
我们为每条边额外储存一个属性next，并赋予每条边一个编号。head数组则用于储存每个起点对应的第一条边。

为了理解链式前向星存图的过程，我们用一张无权值有向图来举个例子：

一开始，没有点，也没有边，所有数组为空且cnt=0。现在我们add(1,2)：
```
head[1] = 0
edges[1].to = 2
edges[1].next = 2
```

这时我们拥有了一条编号为1的边（注意1是编号不是权值），1号边的起点是1号顶点，现在1号顶点没有连接任何边，于是head[1]自然为1。然后1号边通往2号顶点，所以edges[1].to=2。head[1]原本为0，于是edges[1].next=0，这其实就是遍历结束的标志。