以 2d卷积 为例, 参考 torch.nn.functional 的 conv2d

`torch.nn.functional.conv2d(input, weight, bias=None, stride=1, padding=0, dilation=1, groups=1)->Tensor`
+ input: 输入为一个tensor包括(minibatch, in_channels, iH, iW)
+ weight: 权重 或 卷积核
+ bias: 偏置
+ stride: 步幅, 可以是单个数，也可以是一个元祖（H, W）分别指定横向和纵向的步幅
+ padding: 输入图像的上下左右进行填充， 图像变成(H+2padding, W+2padding),填充数字为0 默认不进行填充

```python
import torch
import torch.nn.functional as F

input=torch.tensor([[1,2,0,3,1],
                    [0,1,2,3,1],
                    [1,2,1,0,0],
                    [5,2,3,1,1],
                    [2,1,0,1,1]])

kernel=torch.tensor([[1,2,1],
                     [0,1,0],
                     [2,1,0]])

input=torch.reshape(input, (1,1,5,5))
kernel=torch.reshape(kernel, (1,1,3,3))

print(input.shape)
print(kernel,shape)

output = F.conv2d(input, kernel, stride=1)
```
