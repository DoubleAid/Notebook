# 写一个基于状态量pose的插值函数

写一个基于状态量 pose的插值函数是一个在机器人、动画、SLAM等领域非常常见的需求。Pose通常包含位置（平移）和朝向（旋转）两部分，需要分别进行插值

## Pose 的数据结构定义

首先，我们需要定义 Pose的表示方法。

```python
import numpy as np
from scipy.spatial.transform import Rotation as R
from dataclasses import dataclass
from typing import Union, List

@dataclass
class Pose:
    """Pose数据结构：位置 + 四元数朝向"""
    position: np.ndarray  # [x, y, z]
    orientation: np.ndarray  # 四元数 [x, y, z, w]
    
    def to_matrix(self):
        """将Pose转换为4x4齐次变换矩阵"""
        T = np.eye(4)
        T[:3, 3] = self.position
        T[:3, :3] = R.from_quat(self.orientation).as_matrix()
        return T
    
    @classmethod
    def from_matrix(cls, matrix):
        """从4x4齐次变换矩阵创建Pose"""
        position = matrix[:3, 3]
        orientation = R.from_matrix(matrix[:3, :3]).as_quat()
        return cls(position, orientation)
```

## 线性插值（Lerp）- 最基础版本

这是最简单的插值方法，但对旋转的处理不够自然。

```python
def lerp_pose(pose_start: Pose, pose_end: Pose, t: float) -> Pose:
    """
    线性插值 - 对位置和四元数分别进行线性插值
    
    注意：这种方法对旋转的插值不够自然，可能存在"扭矩"效应
    适用于对精度要求不高的简单应用
    """
    # 参数裁剪
    t = np.clip(t, 0.0, 1.0)
    
    # 位置线性插值
    position_interp = (1 - t) * pose_start.position + t * pose_end.position
    
    # 四元数线性插值（需要归一化）
    quat_interp = (1 - t) * pose_start.orientation + t * pose_end.orientation
    quat_interp = quat_interp / np.linalg.norm(quat_interp)
    
    return Pose(position_interp, quat_interp)
```

## 球面线性插值（SLerp）- 推荐的标准方法

这是处理旋转插值的正确方法，能够保证角速度恒定。

```python
def slerp_pose(pose_start: Pose, pose_end: Pose, t: float) -> Pose:
    """
    球面线性插值 - 对旋转使用SLERP，位置使用LERP
    
    这是处理Pose插值的标准方法
    """
    t = np.clip(t, 0.0, 1.0)
    
    # 1. 位置线性插值
    position_interp = (1 - t) * pose_start.position + t * pose_end.position
    
    # 2. 旋转球面线性插值
    rot_start = R.from_quat(pose_start.orientation)
    rot_end = R.from_quat(pose_end.orientation)
    
    # 使用scipy的SLERP
    rot_interp = R.slerp(rot_start, rot_end, t)
    orientation_interp = rot_interp.as_quat()
    
    return Pose(position_interp, orientation_interp)

def slerp_pose_manual(pose_start: Pose, pose_end: Pose, t: float) -> Pose:
    """
    手动实现SLERP，便于理解数学原理
    """
    t = np.clip(t, 0.0, 1.0)
    
    # 位置线性插值
    position_interp = (1 - t) * pose_start.position + t * pose_end.position
    
    # 手动实现四元数SLERP
    q0 = pose_start.orientation
    q1 = pose_end.orientation
    
    # 计算点积来确定插值方向
    dot = np.dot(q0, q1)
    
    # 如果点积为负，需要取反一个四元数以保证走最短路径
    if dot < 0.0:
        q1 = -q1
        dot = -dot
    
    # 避免数值误差
    dot = np.clip(dot, -1.0, 1.0)
    
    # 计算角度和插值系数
    theta_0 = np.arccos(dot)  # 角度
    theta = theta_0 * t
    
    # 如果角度很小，退化为线性插值
    if theta_0 < 1e-10:
        q_interp = (1 - t) * q0 + t * q1
    else:
        q_interp = (np.sin(theta_0 - theta) * q0 + np.sin(theta) * q1) / np.sin(theta_0)
    
    q_interp = q_interp / np.linalg.norm(q_interp)
    
    return Pose(position_interp, q_interp)
```
