# 基于ceres、g2o、gtsam等熟悉的优化库，写一个自定的edge/factor/residual function

基于一个2D点到线的距离误差作为问题场景，来进行实现

## 问题定义

+ 目标：优化一个2D点的位姿 $T = (x, y, \theta)$ (x, y 坐标和朝向角)
+ 观测：该点观测到一条直线，这条直线可以用法线形式表示 $n \sdot p + d = 0$
+ 残差：点到直线的有符号距离，理想情况下，这个距离为 0

+ 残差计算：对于一个位姿 T 和 一条直线参数 (n, d)， 残差 r 的计算公式为

$$
r = n^T(R(\theta) \sdot p_l + t) + d
$$

其中：

+ $p_l$ 是该点在局部坐标系（机器人坐标系）下的坐标（一个固定的2D点）
+ $R(\theta)$ 是 2D 旋转矩阵
+ $t = [x, y]^T$ 是平移向量

![](5_自动驾驶/images/二维残差计算.png)

## 问题类定义

```cpp
#include <vector>
#include <iostream>
#include <Eigen/Dense>

struct Pose2D {
    double x, y, theta;
    Pose2D(double x = 0, double y = 0, double theta = 0) : x(x), y(y), theta(theta) {}
};

// 直线表示: n · p + d = 0 (法线形式)
struct Line2D {
    Eigen::Vector2d n;
    double d;

    Line2D(const Eigen::Vector2d& normal, double distance) : n(normal.normalized()), d(distance) {}
};
```

## Ceres Solver 实现

Ceres 使用残差块的概念。我们需要定义一个 **仿函数（Functor）** 来计算残差和雅可比矩阵

```cpp
#include <ceres/ceres.h>
#include <Eigen/Core>

class PointToLineFactor : public ceres::SizedCostFunction<1 /* 残差维度 */, 3 /* 参数块维度: x, y, theta */> {
public:
    // 构造函数: 传入局部点坐标到直线参数
    PointToLineFactor(const Eigen::Vector2d& local_pt,
                      const Eigen::Vector2d& line_normal, double line_d)
        : local_pt_(local_pt), line_normal_(line_normal), line_d_(line_d) {}
    
    // 核心函数： 计算残差和 (可选的) 雅可比矩阵
    virtual bool Evaluate(double const* const* parameters,
                          double* residuals,
                          double** jacobians) const {
        // 1. 解包参数 
        const double x      = parameters[0][0];
        const double y      = parameters[0][1];
        const double theta  = parameters[0][2];

        // 2. 计算旋转矩阵 R_wc = [cosθ -sinθ \\ sinθ cosθ]
        const double cos_theta = cos(theta);
        const double sin_theta = sin(theta);

        // 3. 将局部点转换到世界坐标系 p_w = R * p_l + t
        Eigen::Vector2d p_w;
        p_w(0) = cos_theta * local_pt_(0) - sin_theta * local_pt_(1) + x;
        p_w(1) = sin_theta * locak_pt_(1) + cos_theta * local_pt_(1) + y;

        // 4. 计算残差: r = n * p_w + d
        residuals[0] = line_normal_.dot(p_w) + line_d_;

        // 5. 计算雅可比矩阵 (关于位姿 [x, y, theta])
        if (jacobians != nullptr && jacobians[0] != nullptr) {
            // 获取雅可比矩阵指针
            double* jacobian = jacobians[0];

            // 残差对平移 t 的导数：dr / dx = n_x; dr / dy = n_y
            jacobian[0] = line_normal_(0);  // dr / dx
            jacobian[1] = line_normal_(1);  // dr / dy

            // 残差对旋转角 theta 的导数：dr/dθ = n^T · (dR/dθ · p_l)
            // dR/dθ = [-sinθ -cosθ; cosθ -sinθ]
            Eigen::Vector2d dR_dtheta_p;
            dR_dtheta_p(0) = -sin_theta * local_pt_(0) - cos_theta * local_pt_(1);
            dR_dtheta_p(1) = cos_theta * local_pt_(0) - sin_theta * local_pt_(1);
            jacobian[2] = line_normal_.dot(dR_dtheta_p);    // dr/dθ
        }
        return true;
    }
private:
    const Eigen::Vector2d local_pt_;        // 局部坐标系下的点
    const Eigen::Vector2d line_normal_;     // 直线的单位法向量
    const double line_d_;                   // 直线参数 d
};

// 使用方法
int main() {
    // 创建优化问题
    ceres::Problem problem;
    // 设定初始的位姿 [x, y, theta]
    double pose[3] = {0.5, 1.0, 0.1};
    // 假设我们观测到了一些数据，将这些数据通过旋转矩阵逆变换到世界坐标系下
    // 在世界坐标系下应该符合直线，利用这一点计算残差
    Eigen::Vector2d local_pt(0.5, 0.0);
    Eigen::Vector2d line_normal(1, 0);
    double line_d = -2.0;

    // 创建代价函数
    ceres::CostFunction* cost_function = new PointToLineFactor(local_pt, line_normal, line_d);

    // 初始估计值
    problem.AddResidualBlock(cost_function, nullptr /* 损失函数 */， pose);

    // 配置并运行求解器
    ceres::Solver::Options options;
    options.linear_solver_type = ceres::DENSE_QR;
    ceres::Solver::Summary summary;
    ceres::Solve(options, &problem, &summary);

    return 0;
}
```

## g2o 实现

g2o 使用顶点和边的图模型。我们需要定义一个继承 BaseUnaryEdge 的边类。

```cpp
#include "g2o/core/base_vertex.h"
#include "g2o/core/base_unary_edge.h"
#include "g2o/core/block_solver.h"
#include "g2o/core/optimization_algorithm_levenberg.h"
#include "g2o/solver/dense/linear_solver_dense.h"

// G2O 顶点：2D位姿

```
