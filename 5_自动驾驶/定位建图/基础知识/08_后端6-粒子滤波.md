# 后端6 粒子滤波

## 蒙特卡洛方法

蒙特卡洛方法的本质是：利用随机抽样和统计来求解确定性问题的近似解。

简单来说就是：当你不知道一个东西的确切答案时，你可以通过“随机试很多次，然后看统计结果”来猜出一个非常接近的答案。

## 粒子滤波 核心思想

粒子滤波（Particle Filter）是一种基于蒙特卡洛方法的非线性滤波技术，特别适用于处理非高斯、非线性系统的状态估计问题。

用一群粒子（样本）来表示概率分布，每个粒子代表系统的一个可能状态，通过不断更新粒子的权重和位置来逼近真实的后验概率分布。

## 基本步骤

1. 初始化：生成初始粒子群
2. 预测：根据运动模型传播粒子
3. 更新：根据观测数据更新粒子权重
4. 重采样：根据权重重新分配粒子

## 举例说明：机器人定位

假设一个机器人在已知地图中醒来，但不知道自己的位置，需要通过传感器观测来定位

**场景设置**：

+ 地图：一个 10 x 10 的房间，内有桌椅等障碍物
+ 机器人：不知道自己的起始位置
+ 传感器：可以检测到周围墙壁和障碍物的距离

### 粒子滤波过程

#### 步骤一：初始化(先验分布)

```python
import numpy as np
import matplotlib.pyplot as plt

# 在地图上随机生成1000个粒子 (假设粒子可能在任何位置)
num_particles = 1000
particles = np.random.rand(num_particles, 3) * [10, 10, 6.28]  # 随机初始的位姿 10 10 360度
weights = np.ones(num_particles) / num_particles
```

#### 步骤二： 预测（运动模型）

假设机器现在向右移动了一米

```python
def predict(particles, movement, noise_std=0.1):
    """根据运动模型更新粒子位置"""
    dx, dy, dtheta = movement
    # 添加运动噪声
    noise = np.random.normal(0, noise_std, particles.shape)
    particles[:, 0] += dx + noise[:, 0]  # x坐标
    particles[:, 1] += dy + noise[:, 1]  # y坐标  
    particles[:, 2] += dtheta + noise[:, 2]  # 朝向
    return particles

movement = [1.0, 0, 0]
particles = predict(particles, movement)
```

#### 步骤三：更新（观测模型）

假设现在机器人用传感器检测到前方墙壁距离为2米

```python
def update_weights(particles, weights, measuremnet, map_info):
    """根据观测更新粒子权重"""
    for i in range(len(particles)):
        # 基于粒子位置预测观测值
        predicted_measurement = simulate_sensor(particles[i], map_info)
        
        # 计算观测似然（实际观测与预测观测的差异）
        error = abs(predicted_measurement - measurement)
        
        # 更新权重：误差越小，权重越大
        weights[i] = np.exp(-error**2 / (2 * 0.5**2))  # 高斯似然函数
    
    # 归一化权重
    weights += 1.e-300  # 避免除零
    weights /= np.sum(weights)
    return weights
```

#### 步骤四：重采样

```python
def systematic_resample(weights):
    """系统重采样，避免粒子退化"""
    N = len(weights)
    indices = []
    # 按行累加
    cumulative_sum = np.cumsum(weights)
    
    # 生成均匀分布的随机起点
    positions = (np.random.random() + np.arange(N)) / N
    
    i, j = 0, 0
    while i < N:
        if positions[i] < cumulative_sum[j]:
            indices.append(j)
            i += 1
        else:
            j += 1
    return indices

# 计算有效粒子数，判断是否需要重采样
# N_eff = 1 \ sum(N**2)
# 如果每个粒子的权重都相等，N_eff = N
# 最差情况下概率为 N_eff = 1
# 当 N_eff < N / 2 时， 就说明粒子退化严重，需要重新采样
effective_particles = 1.0 / np.sum(weights**2)
if effective_particles < num_particles / 2:
    indices = systematic_resample(weights)
    particles = particles[indices]
    weights = np.ones(num_particles) / num_particles
```
