# 位姿求解

现在我们已经知道了 N 对 特征点， 我们需要计算相机的位姿，即相机的位置和旋转。

## 对极几何 2D - 2D

接下来简单对对极几何进行推断
$$
p_1 = KP \\
p_2 = K(RP + t) \\
x_1 = K^{-1}p_1 \\
x_2 = L^{-1}p_2 \\
$$

最后可以得到 

$$
x_2^Tt \times R x_1 = 0 \\
p_2^TK^{-T}t \times R K^{-1}p_1 = 0 \\
$$

将 $E = t \times R$ 称为本质矩阵 $F = K^{-T}EK^{-1}$ 称为基础矩阵

本质矩阵 E 看上去是平移矩阵(三个自由度) 和 旋转矩阵 (三个自由度) 的组合，但是本质矩阵 E 的秩为 2，所以本质矩阵 E 只有 5 个自由度。

我们使用8个点来估计 本质矩阵， 可以假设这个组合是一个3x3方阵，代入可得

$$
e = [e_1, e_2, e_3, e_4, e_5, e_6, e_7, e_8, e_9]^T
[u_1u_2, u_1v_2, u_1, v_1u_2, v_1v_2, v_1, u_2, v_2, 1] e = 0
$$

这就是一个 8x9 的线性方程组，可以通过 奇异值求解 SVD

单应矩阵是描述两个平面之间关系的矩阵，单应矩阵 H 是本质矩阵 E 的归一化形式，单应矩阵 H 的秩为 3，所以单应矩阵 H 只有 8 个自由度。单应矩阵 H 的计算公式为
$$
p_2 = H p_1 \\
H = K(R - \frac {tn^T} {d})K^{-1}
$$

接下来讲解如何计算基础矩阵

```cpp
vector<Point2f> point1, point2;
// 相机内参
Mat K = (Mat_<double> (3, 3) << 520.0, 0, 325.0, 0, 520, 249, 0, 0, 1);

// 计算基础矩阵
Mat F = findFundamentalMat(point1, point2, FM_8POINT);

// 计算本质矩阵
Point2d principal_point (325.0, 249.0);     // 光心
int focal_length = 520;                     // 焦距
// Mat E = K.inv().t() * F * K.inv();
Mat E = findEssentialMat(point1, point2, focal_length, principal_point, RANSAC);

// 计算单应矩阵
Mat H = findHomography(point1, point2, RANSAC, 3, noArray(), 2000, 0.99);

// 从本质矩阵恢复旋转和平移
recoverPose(E, points1, points2, R, t, focal_length, principal_point);
```

## 三角测量

从上面已经可以得到了相机的位姿，加下来使用三角测量来计算三维点的坐标。

接下来是公式推导
$$
s_1x_1 = s_2Rx_2 + t \\
s_1x_1\times x_1 = 0 = s_2x_1 \times Rx_2 + x_1 \times t
$$

其中 s_2 是相机 2 的尺度因子，s_1 是相机 1 的尺度因子，
由之前的相机模型公式
$$
ZP_{uv} = K(RP_w + t)
$$
可以得到 $s = \frac K Z$

因为，R，t 我们可以由对极几何估计得出，x_1 和 x_2 是归一化坐标的点，所以可以计算出 s_1 和 s_2, 因为R和t不是很准确，需要使用最小二乘法来计算三维点的坐标。
且两个坐标点的位移越大，不确定性越小，结果越精确，对于每次估计的深度应该是符合高斯分布的，使用深度滤波器进行收敛估计

## PnP 问题 已知3D点，再求位姿 

如果我们通过之前的多帧图片，我们已经确定了一些特征点的位置，这样我们就可以通过 PnP 问题来计算相机的位姿。至少需要2个计算和1个验证，所以至少需要 3 个点。

PNP有很多变种，如P3P 即用三对点估计位姿， DLT（直接线性变换），EPnP， UPnP，还可用非线性优化的方法，以及BA优化

### DLT 直接线性变换

直接将旋转矩阵和平移信息设置为参数，然后通过最小二乘法进行优化，这种最后求解的矩阵不一定符合旋转矩阵，还需要QR分解获得旋转矩阵

### P3P 使用三个匹配点

在归一化平面的坐标系中，三个点构成的三角形和图像中的投影相似，通过三角函数的余弦定理，可以得到三个点的旋转矩阵和平移向量的方程组，然后通过求解方程组，得到旋转矩阵和平移向量。

缺点是没法扩展

```cpp
Mat K = (Mat_<double>(3, 3) << 520, 0, 325, 0, 520, 249, 0, 0, 1);
vector<Point3f> pts_3d;     // 匹配的3d点
vector<Point2f> pts_2d;     // 匹配的2d点

Mat r, t;
solvePnP(pts_3d, pts_2d, K, Mat(), r, t, false, cv::SOLVEPNP_EPNP);
// r 为旋转向量，使用Rodrigues公式转化成矩阵
Mat R；
cv::Rodrigues(r, R);
```

### Bundle Adjustment BA

在上面的操作里，我们都是先计算位姿，在计算特征点坐标，再依据已知的坐标再计算位姿，然后再计算特征点坐标，循环往复
而BA的核心就是将 相机位姿和空间点 放在一起优化

简单说就是构建一个最小二乘问题，然后再去优化

如果说我们在两张图片里已经有N个匹配的特征点了, $s_iP_{uv,i} = KR_iP_{wi}, i = 0, 1, 2, ..., N$

我们构建一个 误差名为（重投影误差）$e_i = s_iP_{uv,i} - KR_iP_{wi}$

我们求误差的二范氏，也就是最小二乘，最后使用 高斯牛顿法，LM法等计算出相机位姿和平移向量

## ICP

在3D点云的匹配中，如果向通过两组匹配的点云数据，求解相机的位姿，和BA差不多，只是因为点云的点不多，两者的位置不可能都是相同的，只能查找最近的点认为是相同的点
也就是 ICP (Iterative Closest Point) 迭代最近点，主要分为两种，一种是联立的式子足够多，使用SVD进行求解，第二种就是使用非线性优化的方法进行求解