# 多线程
多线程是多任务处理的一种特殊形式， 一般情况下， 有基于进程和线程的两种类型的多任务处理方式。
+ 基于进程的多任务处理是程序的并发执行
+ 基于线程的多任务处理是统一程序的片段的并发执行

### 基本概念
#### 进程与线程
进程是资源分配和调度的一个独立单位， 而线程是进程的一个实体，是CPU调度和分配的进本单位
同一个线程中的多个线程的内存资源是共享的， 各线程都可以改变进程中的变量。 因此在执行多线程运算的时候要注意执行顺序

#### 并发和并行
并行 （parallenllism）指的是多个任务在同一时刻同时执行
并发 （concurrency）是指在同一时间段内， 对个任务交替进行，虽然看起来像在同时执行，但其实是交替运行的。

### C++线程管理
+ C++11的标准库提供了多线程库，使用时需要 `#include <thread>` 头文件， 该文件主要包含了对线程的管理类 `std::thread` 以及其他管理线程相关的类
+ 每个应用程序至少有一个进程，而每个进程至少有一个主线程， 除了主线程外，在一个进程中还可以创建多个子线程。每个线程都需要一个入口函数， 入口函数范围退出，
该线程也会退出， 主线程就是以 main 函数作为入口函数的线程

#### 启动线程
`std::thread` 的构造函数需要的是可调用 (callable) 类型，除了函数外，还可以调用例如： lambda 表达式、 重载（）运算符的实力
```cpp
#include <iostream>
#include <thread>

using namespace std;

void output(int i) {
    cout << i << endl;
}

int main() {
    for (int i = 0; i < 4; i++) {
        thread t(output, i);
        t.detach();
    }
}
```

**注意：**
+ 把函数对象传入 std::thread 时， 应传入函数名称， 而不加括号
+ 当一个线程启动后， 一定要在该线程销毁前， 调用 t.join() 或者 detach(), 确定以何种方式等待线程结束：
  + detach方式：启动的线程自主在后台运行， 当前的代码继续往下执行， 不等待新线程
  + join方式，等待关联的线程完成， 才会继续执行join() 后的代码
  + 在以detach的方式执行线程时，要将线程访问的局部数据复制到线程的空间（使用按值传递），一定要确保线程没有使用局部变量的引用或者指针，除非你能肯定该线程会在局部作用域结束前执行结束。

